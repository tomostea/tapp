<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>TApp</title>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <link rel="apple-touch-icon" sizes="256x256" href="apple-touch-icon.png">
    <style>
        input {
            font-size: 16px;
        }
    </style>
</head>

<body>
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
    <script src="https://beautifier.io/js/lib/beautify.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@chenfengyuan/vue-countdown@1.1.5/dist/vue-countdown.min.js"></script>

    <input type="file" id="aes_source" />
    <input type="password" id="aes_key" />
    <button onclick="doAes('#aes_key','#aes_source','#aes_result')">encrypt</button>
    <button onclick="doAes('#aes_key','#aes_source','#aes_result',false)">decrypt</button>
    <a href="" id="aes_result">download</a>

    <button id="gUM_do">Do</button>
    <button id="gUM_rec">REC</button>
    <button id="gUM_stop">Stop</button>
    <div id="gUM_res"></div>

    <div id="app"></div>

    <script>
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('sw.js')
                .then((registration) => console.log(registration.scope))
                .catch((err) => console.error(err));
        }
        document.querySelector('#gUM_do').onclick = () => {
            navigator.mediaDevices.getUserMedia(
                { audio: true, video: true }).then(
                    (stream) => {
                        const mediaRecorder = new MediaRecorder(stream);
                        document.querySelector('#gUM_rec').onclick = () => mediaRecorder.start();
                        document.querySelector('#gUM_stop').onclick = () => mediaRecorder.stop();
                        mediaRecorder.ondataavailable = (e) => {
                            const dl = document.createElement('a');
                            dl.setAttribute('download', '');
                            const videoURL = URL.createObjectURL(e.data);
                            dl.href = videoURL;
                            dl.innerText = "DL";
                            document.querySelector('#gUM_res').appendChild(dl);
                        };
                    });
        };
        async function fileRead(openid, textboxid = "", filenameid = "", mime = "plain/text") {
            const file = document.querySelector(openid).files[0];
            const readed = await readFileAsync(file, mime);
            if (textboxid) {
                const textbox = document.querySelector(textboxid);
                const filenameBox = document.querySelector(filenameid);
                textbox.value = readed.result
                filenameBox.value = file.name
            }
            return [readed.result, file.name]
        }
        function readFileAsync(file, mime) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                mime == "plain/text" ? reader.readAsText(file) : reader.readAsArrayBuffer(file);
                reader.onload = () => resolve(reader); // イベントプロパティに関数を設定すると、そのイベントが起きた際に関数が実行される
                reader.onerror = () => reject(reader); // [【JavaScript入門】初心者でも分かるイベント処理の作り方まとめ！ | 侍エンジニア塾ブログ（Samurai Blog） - プログラミング入門者向けサイト](https://www.sejuku.net/blog/61631)
            })
        }

        // [SubtleCrypto.digest() - Web API | MDN](https://developer.mozilla.org/ja/docs/Web/API/SubtleCrypto/digest)
        async function hashKey(text) {
            const msgUint8 = new TextEncoder().encode(text);                           // encode as (utf-8) Uint8Array
            const hashBuffer = await crypto.subtle.digest('SHA-512', msgUint8);           // hash the message
            const hashArray = Array.from(new Uint8Array(hashBuffer));                     // convert buffer to byte array
            const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join(''); // convert bytes to hex string
            return hashHex;
        }
        function keyLoad(raw_key) {
            return new Promise((resolve, reject) => {
                resolve(window.crypto.subtle.importKey(
                    "jwk", //can be "jwk" or "raw"
                    {   //this is an example jwk key, "raw" would be an ArrayBuffer
                        kty: "oct",
                        k: raw_key, // 43bytes : 43/32=1.375 -> Base64で大きくなる分 0123456789abcdefghijklmnopqrstuvwxyzABCDEF-
                        alg: "A256CTR",
                        ext: true,
                    },
                    {   //this is the algorithm options
                        name: "AES-CTR",
                    },
                    false, //whether the key is extractable (i.e. can be used in exportKey)
                    ["encrypt", "decrypt"] //can "encrypt", "decrypt", "wrapKey", or "unwrapKey"
                ))
                    .catch(reject("keyLoad() error"));
            })
        }
        function doAESCTRenc(key, data) {
            return new Promise((resolve, reject) => {
                resolve(window.crypto.subtle.encrypt(
                    {
                        name: "AES-CTR",
                        //Don't re-use counters!
                        //Always use a new counter every time your encrypt!
                        counter: new Uint8Array(16),
                        length: 128, //can be 1-128
                    },
                    key, //from generateKey or importKey above
                    data //ArrayBuffer of data you want to encrypt
                ))
                    .catch(reject("doAESCTRenc() error"));
            })
        }
        function doAESCTRdec(key, data) {
            return new Promise((resolve, reject) => {
                resolve(window.crypto.subtle.decrypt(
                    {
                        name: "AES-CTR",
                        counter: new ArrayBuffer(16), //The same counter you used to encrypt
                        length: 128, //The same length you used to encrypt
                    },
                    key, //from generateKey or importKey above
                    data //ArrayBuffer of the data
                ))
                    .catch(reject("doAESCTRdec() error"));
            })
        }
        // [webcrypto-examples/README.md at master · diafygi/webcrypto-examples · GitHub](https://github.com/diafygi/webcrypto-examples/blob/master/README.md#aes-ctr)
        async function doAes(keyid, inputid, dlid, enc_mode = true) {
            const [fileData, fileName] = await fileRead(inputid, "", "", "binary");
            const keyraw = document.querySelector(keyid).value;
            const hashed = await hashKey(keyraw);
            const sliced = hashed.slice(0, 43);
            const aeskey = await keyLoad(sliced)
            let dl_ = document.querySelector(dlid)
            let processed;
            if (enc_mode) {
                processed = await doAESCTRenc(aeskey, fileData)
                dl_.download = fileName + ".aes"
            } else {
                processed = await doAESCTRdec(aeskey, fileData)
                dl_.download = fileName.replace(".aes", "")
            }
            const blob = new Blob([processed])
            dl_.href = URL.createObjectURL(blob)
            alert(`DONE! : ${fileName}`)
        };

        // [Vue Component の仕様 · vue-loader](https://vue-loader-v14.vuejs.org/ja/start/spec.html)
        // [ブラウザで覚えるES Modules入門 - JavaScriptでモジュールを使う時代 - ICS MEDIA](https://ics.media/entry/16511/)
        Vue.component(VueCountdown.name, VueCountdown);
        const app = new Vue({
            el: '#app',
            // [Vue.jsでinput type="number"としてもvalueは常に文字列を返すので注意！number装飾子を追加しよう - Qiita](https://qiita.com/kopkop/items/f0ad39ca96731b938796)
            template: `
            <div>

            <div>
            sha
            <input v-model="sha_raw">
            <span>{{sha_result}}</span>
            </div>

            <div>
            url
            <input v-model="url_raw">
            <button v-on:click="url_method">Do</button>
            <input type="checkbox" v-model="url_mode" value="true">encode
            <span>{{url_result}}</span>
            </div>

            <div>
            base
            <input v-model="base_raw">
            <button v-on:click="base_method">Do</button>
            <input type="checkbox" v-model="base_mode" value="true">encode
            <span>{{base_result}}</span>
            </div>

            <div>
            pass
            <input type="number" v-model.number="pass_length">
            <input type="checkbox" v-model="pass_mode" value="lower">Lowercase
            <input type="checkbox" v-model="pass_mode" value="upper">Uppercase
            <input type="checkbox" v-model="pass_mode" value="number">Number
            <input type="checkbox" v-model="pass_mode" value="symbol">Symbol
            <button v-on:click="pass_method">Do</button>
            <span>{{pass_result}}</span>
            </div>

            <div>
            timer
            <input v-model="timer_nums">
            <button v-on:click="timer_method">Do</button>
            <div v-for="c in timer_seconds" ref="time">
                <countdown :time="c * 1000">
                    <!-- 親コンポーネント (HTML (Vueインスタンス)) がデータを受け取る時はv-slot 逆はv-bind -->
                    <template v-slot="props">{{ props.days }} d {{ props.hours }} h
                        {{ props.minutes }} m {{ props.seconds }} s</template>
                </countdown>
            </div>
            </div>

            <div>
            fin
            <input v-model="fin_raw">
            <span>{{fin_result}}</span>
            </div>

            <div>
            od
            <input v-model="od_raw">
            <span>{{od_result}}</span>
            </div>

            <div>
            calc
            <input v-model="calc_raw">
            <span>{{calc_result}}</span>
            </div>

            <div>
            rss
            <input v-model="rss_raw">
            <button v-on:click="rss_method">Do</button>
            <span>{{rss_result}}</span>
            </div>

            <div>
            jrnl
            <input v-model="jrnl_raw">
            <button v-on:click="jrnl_method">Do</button>
            <span>{{jrnl_result}}</span>
            </div>

            <div>
            btfy
            <textarea v-model="btfy_raw"></textarea>
            <textarea v-model="btfy_result"></textarea>
            </div>

            </div>
            `,
            data: {
                sha_raw: '',
                sha_result: '',
                url_raw: "",
                url_result: "",
                url_mode: [],
                base_raw: "",
                base_result: "",
                base_mode: [],
                pass_result: '',
                pass_length: 12,
                pass_mode: ["lower", "upper", "number"],
                timer_nums: [],
                timer_seconds: [],
                fin_raw: '',
                fin_result: 0,
                od_raw: '',
                od_result: '',
                calc_raw: '',
                calc_result: 0,
                rss_raw: '',
                rss_result: '',
                jrnl_raw: '',
                jrnl_result: '',
                btfy_raw: '',
                btfy_result: '',
            },
            methods: {
                url_method: function () {
                    this.url_result = this.url_mode.length == 0 ? decodeURI(this.url_raw) : encodeURI(this.url_raw)
                },
                // [JavaScriptでBase64エンコード・デコード（UTF-8も） - Qiita](https://qiita.com/i15fujimura1s/items/6fa5d16b1e53f04f3b06)
                base_method: function () {
                    this.base_result = this.base_mode.length == 0 ? decodeURIComponent(atob(this.base_raw)) : btoa(encodeURIComponent(this.base_raw))
                },
                // [](https://luck2515.com/20200312/createPassword)
                pass_method: function () {
                    const lowercase = "abcdefghijklmnopqrstuvwxyz"
                    const uppercase = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                    const numbers = "0123456789"
                    const symbols = "`˜!@#$%^&*()_+-={}[]|:;\"'<>,.?/"
                    const length = this.pass_length;
                    const useLowercase = this.pass_mode.includes("lower");
                    const useUppercase = this.pass_mode.includes("upper");
                    const useNumber = this.pass_mode.includes("number");
                    const useSymbol = this.pass_mode.includes("symbol");
                    let password = ""
                    strList = `${useLowercase ? lowercase : ""}${useUppercase ? uppercase : ""}${useNumber ? numbers : ""}${useSymbol ? symbols : ""}`
                    secureMathRandom = () => window.crypto.getRandomValues(new Uint32Array(1))[0] / 4294967295;
                    for (let j = 0; j < length; j++) {
                        password += strList[Math.floor(secureMathRandom() * strList.length)]
                    }
                    this.pass_result = password
                },
                // <button @click="addNum">{{num}}</button>
                timer_method: function () {
                    this.timer_seconds = this.timer_nums.split(",")
                },
                // [rss-detect-bookmarklet/rss.js at master · aziraphale/rss-detect-bookmarklet](https://github.com/aziraphale/rss-detect-bookmarklet/blob/master/rss.js)
                rss_method: function () {
                    fetch("https://cors-anywhere.herokuapp.com/" + this.rss_raw)
                        .then((res) => res.text())
                        .then((htmlstr) => {
                            let query, elements, links = [];
                            try {
                                query = "[href$='.atom'], [href*='.atom?'], [href$='.rss'], [href*='.rss?'], [href*='/rss.'], [href*='/feed.'], [href*='/atom.'], [href*='//feeds.feedburner.com/'], [href*='/feed/'], [type='application/atom+xml'], [type='application/rss+xml']";
                                const html = new DOMParser().parseFromString(htmlstr, "text/html")
                                console.log(html)
                                elements = html.querySelectorAll(query);
                                if (elements && elements.length > 0) {
                                    for (let element of elements) {
                                        links.push(element.href);
                                    }
                                }
                            } catch (e) { }
                            if (links.length > 0) {
                                this.rss_result = links;
                            } else {
                                this.rss_result = "Not Find";
                            }
                        })
                },
                jrnl_method: function () {
                    const today = new Date();
                    const date = `${today.getFullYear()}-${("0" + (today.getMonth() + 1)).slice(-2)}-${("0" + today.getDate()).slice(-2)}`;
                    const result = {
                        P577: date,
                        P793: "",
                        P4271: 0,
                        P135: "http://www.wikidata.org/entity/",
                        P1476: "",
                    };
                    this.jrnl_result = JSON.stringify(result, null, 1)
                    const art = this.jrnl_raw
                    if (art) { window.open(`https://query.wikidata.org/#PREFIX%20rdfs:%20<http://www.w3.org/2000/01/rdf-schema#>select%20distinct%20*%20where%20{%20?s%20rdfs:label%20?o%20filter%20regex%20(?o,%20"${art}").}limit%201`); }
                }
            },
            watch: {
                // [Vue.js プロパティの変更をデータに反映する - 前人未踏の領域へ WEB・インフラ・プログラミング全般編](https://taker.hatenablog.com/entry/2020/04/07/083542)
                // [SHA256のハッシュをJavaScriptのWeb標準のライブラリだけで計算する - nwtgck / Ryo Ota](https://scrapbox.io/nwtgck/SHA256のハッシュをJavaScriptのWeb標準のライブラリだけで計算する)
                sha_raw: async function () {
                    const buff = new Uint8Array([].map.call(this.sha_raw, (c) => c.charCodeAt(0))).buffer;
                    const digest = await crypto.subtle.digest('SHA-256', buff);
                    this.sha_result = [].map.call(new Uint8Array(digest), x => ('00' + x.toString(16)).slice(-2)).join('');
                },
                fin_raw: function () {
                    const json = JSON.parse(this.fin_raw);
                    const values = Object.values(json);
                    const result = values.reduce((sum, n) => sum += Number(n));
                    this.fin_result = result
                },
                od_raw: function () {
                    const amount = 10000;
                    const target = 0.1;
                    const dilution = 50;
                    const odraw = this.od_raw.split(",");
                    const ods = odraw.map(x => parseFloat(x));
                    const sum = ods.reduce((a, x) => a + x);
                    const avg = sum / ods.length;
                    const result = amount * (target / (dilution * avg));
                    const result2 = (400 * (0.300 / avg)) / 2;
                    this.od_result = `avg: ${avg}\nresult: ${result}\nresult2: ${result2}`;
                },
                calc_raw: function () {
                    this.calc_result = eval(this.calc_raw);
                },
                btfy_raw: function () {
                    this.btfy_result = js_beautify(this.btfy_raw);
                }
            }
        })
    </script>
</body>

</html>