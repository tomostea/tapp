<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>TApp</title>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <link rel="icon" href="favicon.ico">
    <link rel="apple-touch-icon" sizes="256x256" href="apple-touch-icon.png">
</head>

<body>
    <input type="file" id="aes_source" />
    <input type="password" id="aes_key" />
    <button onclick="doAes('#aes_key','#aes_source','#aes_result')">encrypt</button>
    <button onclick="doAes('#aes_key','#aes_source','#aes_result',false)">decrypt</button>
    <a href="" id="aes_result">download</a>

    <button id="gUM_do">Do</button>
    <button id="gUM_rec">REC</button>
    <button id="gUM_stop">Stop</button>
    <div id="gUM_res"></div>

    <script>
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('sw.js').then(function (registration) {
                // 登録成功
                console.log('ServiceWorker registration successful with scope: ', registration.scope);
            }).catch(function (err) {
                // 登録失敗
                console.log('ServiceWorker registration failed: ', err);
            });
        }
        document.querySelector('#gUM_do').onclick = () => {
            navigator.mediaDevices.getUserMedia(
                { audio: true, video: true }).then(
                    (stream) => {
                        const mediaRecorder = new MediaRecorder(stream);
                        document.querySelector('#gUM_rec').onclick = () => mediaRecorder.start();
                        document.querySelector('#gUM_stop').onclick = () => mediaRecorder.stop();
                        mediaRecorder.ondataavailable = (e) => {
                            const dl = document.createElement('a');
                            dl.setAttribute('download', '');
                            const videoURL = URL.createObjectURL(e.data);
                            dl.href = videoURL;
                            dl.innerText = "DL";
                            document.querySelector('#gUM_res').appendChild(dl);
                        };
                    });
        };
        async function fileRead(openid, textboxid = "", filenameid = "", mime = "plain/text") {
            let file = document.querySelector(openid).files[0];
            let readed = await readFileAsync(file, mime);
            if (textboxid) {
                let textbox = document.querySelector(textboxid);
                let filenameBox = document.querySelector(filenameid);
                textbox.value = readed.result
                filenameBox.value = file.name
            }
            return [readed.result, file.name]
        }
        function readFileAsync(file, mime) {
            return new Promise((resolve, reject) => {
                let reader = new FileReader();
                reader.onload = () => {
                    resolve(reader);
                };
                reader.onerror = reject;
                if (mime == "plain/text") {
                    reader.readAsText(file);
                } else {
                    reader.readAsArrayBuffer(file);
                }
            })
        }

        // [SubtleCrypto.digest() - Web API | MDN](https://developer.mozilla.org/ja/docs/Web/API/SubtleCrypto/digest)
        async function hashKey(text) {
            const msgUint8 = new TextEncoder().encode(text);                           // encode as (utf-8) Uint8Array
            const hashBuffer = await crypto.subtle.digest('SHA-512', msgUint8);           // hash the message
            const hashArray = Array.from(new Uint8Array(hashBuffer));                     // convert buffer to byte array
            const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join(''); // convert bytes to hex string
            return hashHex;
        }
        function keyLoad(raw_key) {
            return new Promise((resolve, reject) => {
                resolve(window.crypto.subtle.importKey(
                    "jwk", //can be "jwk" or "raw"
                    {   //this is an example jwk key, "raw" would be an ArrayBuffer
                        kty: "oct",
                        k: raw_key, // 43bytes : 43/32=1.375 -> Base64で大きくなる分 0123456789abcdefghijklmnopqrstuvwxyzABCDEF-
                        alg: "A256CTR",
                        ext: true,
                    },
                    {   //this is the algorithm options
                        name: "AES-CTR",
                    },
                    false, //whether the key is extractable (i.e. can be used in exportKey)
                    ["encrypt", "decrypt"] //can "encrypt", "decrypt", "wrapKey", or "unwrapKey"
                ))
                    .catch(reject("keyLoad() error"));
            })
        }
        function doAESCTRenc(key, data) {
            return new Promise((resolve, reject) => {
                resolve(window.crypto.subtle.encrypt(
                    {
                        name: "AES-CTR",
                        //Don't re-use counters!
                        //Always use a new counter every time your encrypt!
                        counter: new Uint8Array(16),
                        length: 128, //can be 1-128
                    },
                    key, //from generateKey or importKey above
                    data //ArrayBuffer of data you want to encrypt
                ))
                    .catch(reject("doAESCTRenc() error"));
            })
        }
        function doAESCTRdec(key, data) {
            return new Promise((resolve, reject) => {
                resolve(window.crypto.subtle.decrypt(
                    {
                        name: "AES-CTR",
                        counter: new ArrayBuffer(16), //The same counter you used to encrypt
                        length: 128, //The same length you used to encrypt
                    },
                    key, //from generateKey or importKey above
                    data //ArrayBuffer of the data
                ))
                    .catch(reject("doAESCTRdec() error"));
            })
        }
        // [webcrypto-examples/README.md at master · diafygi/webcrypto-examples · GitHub](https://github.com/diafygi/webcrypto-examples/blob/master/README.md#aes-ctr)
        async function doAes(keyid, inputid, dlid, enc_mode = true) {
            const [fileData, fileName] = await fileRead(inputid, "", "", "binary");
            const keyraw = document.querySelector(keyid).value;
            const hashed = await hashKey(keyraw);
            const sliced = hashed.slice(0, 43);
            const aeskey = await keyLoad(sliced)
            let dl_ = document.querySelector(dlid)
            let processed;
            if (enc_mode) {
                processed = await doAESCTRenc(aeskey, fileData)
                dl_.download = fileName + ".aes"
            } else {
                processed = await doAESCTRdec(aeskey, fileData)
                dl_.download = fileName.replace(".aes", "")
            }
            const blob = new Blob([processed])
            dl_.href = URL.createObjectURL(blob)
            alert(`DONE! : ${fileName}`)
        };
    </script>
</body>

</html>
